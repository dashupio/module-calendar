<page-calendar-view>
  <div>
    <a href="#!" class="d-block alert alert-info mb-3" if={ !props.page.get('data.models.0.model') } onclick={ (e) => props.onConfig(e) }>
      <i class="fa fa-exclamation-triangle mr-2" />
      Please select at least one <b>model</b> for the calendar.
    </a>
    <a href="#!" class="d-block alert alert-info mb-3" if={ !props.page.get('data.models.0.form') } onclick={ (e) => props.onConfig(e) }>
      <i class="fa fa-exclamation-triangle mr-2" />
      Please select at least one <b>form</b> for the calendar.
    </a>
    <a href="#!" class="d-block alert alert-info mb-3" if={ !props.page.get('data.models.0.date') } onclick={ (e) => props.onConfig(e) }>
      <i class="fa fa-exclamation-triangle mr-2" />
      Please select at least one <b>date field</b> for the calendar.
    </a>

    <div if={ props.page.get('data.models.0.date') && !loading('calendar') }>
      <calendar-week if={ props.page.get('user.calendar') === 'week' } ref={ ref('calendar') } get-items={ (s, e) => getItems(s, e) } { ...props } />
      <calendar-month if={ !props.page.get('user.calendar') || props.page.get('user.calendar') === 'month' } ref={ ref('calendar') } get-items={ (s, e) => getItems(s, e) } { ...props } />
    </div>
    <div if={ props.page.get('data.models.0.date') && loading('calendar') } class="text-center my-5 py-5">
      <i class="fa fa-spin fa-spinner h1" />
    </div>
  </div>

  <script>
    // require base class
    import Moment from 'moment';
    import { extendMoment } from 'moment-range';

    // extend
    const moment = extendMoment(Moment);

    // day week month
    import calendarWeek from '../../calendar/week';
    import calendarMonth from '../../calendar/month';

    // export default
    export default class PageCalendarView {

      /**
       * local components
       */
      static get components() {
        // return components
        return {
          calendarWeek,
          calendarMonth,
        };
      }

      /**
       * on before mount
       */
      onBeforeMount(...args) {
        // bind init
        this.init = this.init.bind(this);
        this.getQuery = this.getQuery.bind(this);

        // check frontend
        if (typeof window === 'undefined') return;

        // safe update
        this.safeUpdate = () => {
          this.update();
        };

        // add listeners
        this.props.page.on('do.user.where', this.init);
        this.props.page.on('do.user.filter', this.init);
        this.props.page.on('do.data.models', this.init);
        this.props.page.on('do.user.calendar', this.init);
      }

      /**
       * on before mount
       */
      onBeforeUnmount(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // add listeners
        this.props.page.removeListener('do.user.where', this.init);
        this.props.page.removeListener('do.user.filter', this.init);
        this.props.page.removeListener('do.data.models', this.init);
        this.props.page.removeListener('do.user.calendar', this.init);

        // check data
        if (this.state.datas) this.state.datas.forEach((data) => {
          // check data
          if (!data || !data.deafen) return;

          // data
          data.deafen();
          data.removeListener('update', this.safeUpdate);
        });
      }

      /**
       * on updated
       */
      onUpdated(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // set ps
        if (!this.$('.ps') && this.$('.calendar-cols')) {
          // perfect scrollbar
          this.ps = new PerfectScrollbar(this.$('.calendar-cols'));
        }

        // check search
        if (this.search !== this.props.search || this.date !== this.props.date) {
          // init
          this.date   = this.props.date;
          this.search = this.props.search;
          this.init();
        }
      }

      /**
       * on mounted
       */
      onMounted(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // init
        this.init();
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // INIT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * init
       */
      async init() {
        // current
        if (!this.shownFirst && this.props.current) {
          // shown first
          this.shownFirst = true;

          // on current
          this.props.onItem(null, this.props.current);
        }

        // check legacy
        if (this.props.page.get('data.model') && !this.props.page.get('data.models.0')) {
          // set data
          await this.props.data('models', [{
            tag     : this.props.page.get('data.tag'),
            form    : this.props.page.get('data.form'),
            user    : this.props.page.get('data.user'),
            date    : this.props.page.get('data.date'),
            model   : this.props.page.get('data.model'),
            filter  : this.props.page.get('data.filter'),
            display : this.props.page.get('data.display'),
          }]);
        }

        // check
        if (this.initializing) return;
        if (!this.props.page.get('data.models.0.form')) return;
        if (!this.props.page.get('data.models.0.model')) return;

        // initializing
        this.initializing = true;

        // loading
        this.update({
          loading : new Date(),
        });

        // check data
        if (this.state.datas) this.state.datas.forEach((data) => {
          // check data
          if (!data || !data.deafen) return;

          // data
          data.deafen();
          data.removeListener('update', this.safeUpdate);
        });

        // find data
        const queries = (this.props.page.get('data.models') || []).map(this.getQuery);

        // find
        const datas = await Promise.all(queries.map(async (query) => {
          // return query
          return query && query.listen ? await query.listen() : [];
        }));

        // loading
        this.update({
          datas,

          loading : false,
        });

        // safe update
        datas.forEach((data) => {
          // check data
          if (data && data.on) data.on('update', this.safeUpdate);
        });

        // unset
        this.initializing = false;
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // GET METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * get query
       */
      getQuery(opts) {
        // get form
        const form = this.props.dashup.page(opts.form);
        const calendar = this.props.page.get('user.calendar') || 'month';

        // set query
        let query = this.props.dashup.page(opts.model);

        // loop forms
        query = query.in('_meta.form', [opts.form]);

        // load filter
        let filter = null;

        // try/catch
        try {
          filter = JSON.parse(opts.filter);
        } catch (e) {}

        // add initial where
        if (filter) {
          // add wheres
          filter.forEach((where) => {
            // where
            query = query.where(where);
          });
        }

        // search
        if (this.props.search && this.props.search.length) {
          // add search
          query = query.search(this.props.search);
        }

        // test by user
        if ((this.props.page.get('user.filter') || {}).me) {
          // get user fields
          const userFields = [...(form.get('data.fields') || [])].filter((f) => (opts.user || []).includes(f.uuid));
          
          // loop fields
          query = query[userFields.length > 1 ? 'or' : 'where'](...(userFields.map((userField) => {
            // check user field
            if (!userField) return;

            // return or
            return {
              [userField.name || userField.uuid] : this.props.dashup.get('_meta.member'),
            };
          })));
        }

        // user query
        (this.props.page.get('user.where') || []).forEach((where) => {
          // types
          const numberTypes = ['gt', 'lt', 'gte', 'lte'];

          // add query
          query = query[where[0]](where[1], numberTypes.includes(where[0]) ? parseFloat(where[2]) : where[2]);
        });

        // get filter tags
        if ((this.props.page.get('user.filter.tags') || []).length) {
          // check vals
          const tagFields = [...(form.get('data.fields') || [])].filter((f) => (opts.tag || []).includes(f.uuid));

          // loop fields
          query = query[tagFields.length > 1 ? 'or' : 'where'](...(tagFields.map((tagField) => {
            // check tag field
            if (!tagField) return;

            // return or
            return {
              [tagField.name || tagField.uuid] : this.props.page.get('user.filter.tags')
            };
          })));
        }

        // get start/end
        const dateField = (form.get('data.fields') || []).find((f) => f.uuid === opts.date);

        // date field
        if (!dateField) return [];

        // start end date
        let endDate   = null;
        let startDate = null;

        // calendar
        if (calendar === 'month') {
          // week
          endDate = moment(this.props.date || new Date()).endOf('month').toDate();
          startDate = moment(this.props.date || new Date()).startOf('month').toDate();
        } else if (calendar === 'week') {
          // week
          endDate = moment(this.props.date || new Date()).endOf('week').toDate();
          startDate = moment(this.props.date || new Date()).startOf('week').toDate();
        } else if (calendar === 'day') {
          // units
          endDate = moment(this.props.date || new Date()).endOf('day').toDate();
          startDate = moment(this.props.date || new Date()).startOf('day').toDate();
        }

        // add where
        query = query.or({
          [`${dateField.name || dateField.uuid}.end`] : {
            $lt : endDate,
          },
          [`${dateField.name || dateField.uuid}.start`] : {
            $gt : startDate,
          },
        }, {
          [`${dateField.name || dateField.uuid}.repeat`] : true,
          [`${dateField.name || dateField.uuid}.until`] : null,
          [`${dateField.name || dateField.uuid}.start`] : {
            $lt : endDate,
          },
        }, {
          [`${dateField.name || dateField.uuid}.repeat`] : true,
          [`${dateField.name || dateField.uuid}.until`] : {
            $gt : startDate,
          },
          [`${dateField.name || dateField.uuid}.start`] : {
            $lt : endDate,
          },
        });

        // return query
        return query;
      }

      /**
       * get items
       *
       * @param {String} col
       */
      getItems(start, end) {
        // get check range
        const range = moment.range(start, end);

        // check frontend
        if (!this.state.datas) return [];
        if (typeof window === 'undefined') return [];

        // loop datas
        const filtered = [].concat(...((this.props.page.get('data.models') || []).map((model, i) => {
          // check model
          if (!model) return [];

          // get form
          const form = this.props.dashup.page(model.form);

          // start/end fields
          const dateField = (form.get('data.fields') || []).find((f) => f.uuid === model.date);

          // check end/start
          if (!dateField) return [];

          // keys
          const dateKey = dateField.name || dateField.uuid;

          // return queries
          return [...(this.state.datas[i])].reduce((accum, row) => {
            // get date
            const dateValue = row.get(dateKey);

            // return
            if (!dateValue || !(typeof dateValue === 'object')) return accum;

            // start/end
            let rowEnd     = new Date(dateValue.end || 0);
            let rowUntil   = ((dateValue.rep || {}).ends || 'forever') !== 'forever' && !isNaN(new Date(dateValue.until).getTime()) ? new Date(dateValue.until) : null;
            const rowStart = new Date(dateValue.start || 0);

            // end
            if (!dateValue.end && dateValue.duration) {
              // duration add
              rowEnd = new Date(rowStart.getTime() + dateValue.duration);
            }

            // check repeat
            if (!dateValue.repeat || !dateValue.rep || !dateValue.rep.period) {
              // range
              const subRange = moment.range(rowStart, rowEnd);

              // check ends within or starts within
              if (range.overlaps(subRange)) {
                // push row
                accum.push([subRange, row, model]);
              }

              // return accum
              return accum;
            }

            // check until
            if (rowUntil && rowUntil < end) return accum;

            // next date
            let next = moment(rowStart);

            // chech while
            while (next.toDate() < end) {
              // get end
              const nextEnd = new Date(next.toDate().getTime() + (dateValue.duration || 0));
              const subRange = moment.range(next.toDate(), nextEnd);

              // check ends within or starts within
              if (range.overlaps(subRange)) {
                // return accum
                accum.push([subRange, row, model]);
                return accum;
              }

              // add
              next.add(dateValue.rep.amount || 1, dateValue.rep.period || 'minute');
            }

            // fail
            return accum;
          }, []);
        }))).sort(([a], [b]) => {
          // sort order
          const aS = a.start.toDate();
          const bS = b.start.toDate();

          // check order
          if (bS > aS) return -1;
          if (bS < aS) return 1;
          return 0;
        });

        // return filtered
        return filtered;
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // MISC METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * ref
       */
      ref(name) {
        // set refs
        if (!this.refs) this.refs = {};

        // return ref function
        return (that) => {
          // set ref
          this.refs[name] = that;
        };
      }

      /**
       * classes
       */
      classes(obj) {
        // return classes
        return Object.keys(obj).filter((key) => !!obj[key]).join(' ');
      }

      /**
       * set loading
       */
      loading(type, way) {
        // set loading
        if (!this.__loading) this.__loading = new Map();

        // check loading
        if (!type) return !!Array.from(this.__loading.values()).find((v) => v);
        if (typeof way === 'undefined') return !!this.__loading.get(type);

        // set loading
        this.__loading.set(type, way);
        this.update();
      }
    }
  </script>
</page-calendar-view>